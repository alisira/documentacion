<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Capítulo&nbsp;3.&nbsp;Desarrollando la Logica de Negocio</title>
<link rel="stylesheet" href="Cap%C3%ADtulo%C2%A03.%C2%A0Desarrollando%20la%20Logica%20de%20Negocio%20Archivos/html.css" type="text/css">
<link rel="home" href="http://www.uv.es/grimo/teaching/SpringMVCv4PasoAPaso/index.html" title="Desarrollando una aplicación Spring Framework MVC v4 + JPA paso a paso">
<link rel="up" href="http://www.uv.es/grimo/teaching/SpringMVCv4PasoAPaso/index.html" title="Desarrollando una aplicación Spring Framework MVC v4 + JPA paso a paso">
<link rel="previous" href="http://www.uv.es/grimo/teaching/SpringMVCv4PasoAPaso/part2.html" title="Capítulo&nbsp;2.&nbsp;Desarrollando y Configurando la Vista y el Controladorr">
<link rel="next" href="http://www.uv.es/grimo/teaching/SpringMVCv4PasoAPaso/part4.html" title="Capítulo&nbsp;4.&nbsp;Desarrollando la Interface Web">
</head>
<body alink="#0000ff" link="#0000ff" text="black" vlink="#840084" bgcolor="white">
<div xmlns="http://www.w3.org/TR/xhtml1/transitional" style="border: 1px solid black; background-color: white; height: 73px;"><a style="border: medium none;" href="http://www.springframework.org/" title="The Spring Framework"><img style="border: medium none;" src="Cap%C3%ADtulo%C2%A03.%C2%A0Desarrollando%20la%20Logica%20de%20Negocio%20Archivos/xdev-spring_logo.jpg"></a><a style="border: medium none;" href="http://www.springsource.com/" title="SpringSource"><img style="border: medium none; position: absolute; padding-top: 5px; right: 42px;" src="Cap%C3%ADtulo%C2%A03.%C2%A0Desarrollando%20la%20Logica%20de%20Negocio%20Archivos/springsource-banner-rhs.png"></a></div>
<div class="chapter" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title"><a name="part3"></a>Capítulo&nbsp;3.&nbsp;Desarrollando
la Lógica de Negocio</h2>
</div>
</div>
<div></div>
</div>


<p>Ésta es la Parte 3 del tutorial paso a paso para desarrollar una
aplicación Spring MVC. En esta sección, adoptaremos un acercamiento
pragmático al Test-Driven Development (TDD o Desarrollo Conducido por
Tests) para crear los objetos de dominio e implementar la lógica de
negocio para nuestro <a href="http://www.uv.es/grimo/teaching/SpringMVCv4PasoAPaso/overview.html#overview-application-overview" title="3.&nbsp;La aplicación que vamos a construir">sistema de
mantenimiento de inventario</a>. Esto significa que "escribiremos un poco de
código, lo testearemos, escribiremos un poco más de código, lo
volveremos a testear..." En la <a href="http://www.uv.es/grimo/teaching/SpringMVCv4PasoAPaso/part1.html" title="Capítulo&nbsp;1.&nbsp;Aplicación Base y Configuración del Entorno">Parte
1</a> hemos configurado el entorno y montado la aplicación básica. En la <a href="http://www.uv.es/grimo/teaching/SpringMVCv4PasoAPaso/part2.html" title="Capítulo&nbsp;2.&nbsp;Desarrollando y Configurando la Vista y el Controlador">Parte
2</a> hemos refinado la aplicación desacoplando la vista del controlador.</p>

<p>Spring permite hacer las cosas simples fáciles y las difíciles
posibles. La estructura fundamental que hace esto posible es el uso de <tt class="literal">Plain Old Java Objects (POJOs u Objetos Normales
Java) </tt> por Spring. Los POJOs son esencialmente clases nomales Java
libres de cualquier contrato (normalmente impuesto por un framework o
arquitectura a traves de subclases o de la implementación de
interfaces). Los POJOs son objetos normales Java que están libres de
dichas obligaciones, haciendo la programación orientada a objetos
posible de nuevo. Cuando trabajes con Spring, los objetos de dominio y
los servicios que implementes seran POJOs. De hecho, casi todo lo que
implementes debería ser un POJO. Si no es así, deberías preguntarte a ti
mismo porqué no ocurre esto. En esta sección, comenzaremos a ver la
simplicidad y potencia de Spring.</p>



<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;"><a name="step3.1"></a>3.1.&nbsp;Revisando
la regla de negocio del Sistema de Mantenimiento de Inventario</h2>
</div>
</div>
<div></div>
</div>

<p>En nuestro sistema de mantenimiento de inventario tenemos dos
conceptos: el de producto, y el de servicio para manejarlo. Supongamos en este tutorial que el
negocio solicita la capacidad de incrementar precios sobre todos los
productos. Cualquier decremento será hecho sobre cada producto en concreto,
pero esta característica está fuera de la funcionalidad de nuestra
aplicación. Las reglas de validación para incrementar precios son:</p>
<div class="itemizedlist">
<ul type="disc">
	<li>
	<p>El incremento máximo esta limitado al 50%.</p>

	</li>
	<li>
	<p>El incremento mínimo debe ser mayor del 0%.</p>
	</li>
</ul>
</div>

<p>A continuación puedes ver el diagrama de clases de nuestro sistema de
mantenimiento de inventario.</p>

<div class="screenshot">
<div class="mediaobject" align="center"><img src="Cap%C3%ADtulo%C2%A03.%C2%A0Desarrollando%20la%20Logica%20de%20Negocio%20Archivos/inventory-system-classdiagram.png" align="middle">
<div class="caption">
<p>El diagrama de clases para el sistema de mantenimiento de
inventario</p>

</div>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;"><a name="step3.2"></a>3.2.&nbsp;Añadir
algunas clases a la lógica de negocio</h2>
</div>
</div>
<div></div>
</div>

<p>Añadamos ahora más lógica de negocio en la forma de una clase <tt class="classname">Product</tt> y un servicio al que llamaremos <tt class="interfacename">ProductManager</tt> que gestionará todos los
productos. Para separar la lógica de la web de la lógica de negocio,
colocaremos las clases relacionadas con la capa web en el paquete <tt class="literal">'web'</tt> y crearemos dos nuevos paquetes: uno para
los objetos de servicio, al que llamaremos <tt class="literal">'service'</tt>,
y otro para los objetos de dominio al que llamaremos <tt class="literal">'domain'</tt>.</p>

<p>Primero implementamos la clase <tt class="classname">Product</tt>
como un POJO con un constructor por defecto (que es provisto si no
especificamos ningun constructor explícitamente), así como métodos
getters y setters para las propiedades <tt class="literal">'description'</tt>
y <tt class="literal">'price'</tt>. Además haremos que la clase
implemente la interfaz <tt class="interfacename">Serializable</tt>, aspecto no
necesario en este momento para nuestra aplicación, pero que será necesario más
tarde cuando persistamos y almacenemos su estado. Esta clase es un
objeto de dominio, por lo tanto pertenece al paquete <tt class="literal">'domain'</tt>.</p>

<p><tt class="filename">'springapp/src/main/java/com/companyname/springapp/domain/Product.java'</tt>:</p>
<pre class="programlisting">package com.companyname.springapp.domain;

import java.io.Serializable;

public class Product implements Serializable {

    private static final long serialVersionUID = 1L;

    private String description;
    private Double price;
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public Double getPrice() {
        return price;
    }
    
    public void setPrice(Double price) {
        this.price = price;
    }
    
    public String toString() {
        StringBuffer buffer = new StringBuffer();
        buffer.append("Description: " + description + ";");
        buffer.append("Price: " + price);
        return buffer.toString();
    }
}</pre>

<p>Escribamos ahora una unidad de test para nuestra clase <tt class="classname">Product</tt>.
 Algunos programadores no se molestan en escribir tests para los getters
 y setters, también llamado código 'auto-generado'. Normalmente, supone 
demasiado tiempo enfrascarse en el debate (como este párrafo demuestra) 
sobre si los getters y setters necesitan ser testeados, ya que son 
métodos demasiado 'triviales'. Nosotros escribiremos los tests debido a 
que: a) son triviales de escribir; b) tendremos siempre los tests y 
preferimos pagar el precio de perder un poco de tiempo por la sola 
ocasión entre cien en que nos salvemos de un error producido por un 
getter o setter; y c) porque mejoran la cobertura de los tests. Creamos 
un stub de <tt class="classname">Product</tt> y testeamos cada método 
getter y setter como una pareja en un test simple. Normalmente, 
escribirás uno o más métodos de test por cada método de la clase, donde 
cada uno de estos métodos compruebe una condicion particular en
el método de la clase (como por ejemplo, verificar un valor <tt class="methodname">null</tt>
pasado al método, etc.).</p>

<p><tt class="filename">'springapp/src/test/java/com/companyname/springapp/domain/ProductTests.java'</tt>:</p>
<pre class="programlisting">package com.companyname.springapp.domain;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

public class ProductTests {

    private Product product;

    @Before
    public void setUp() throws Exception {
        product = new Product();
    }

    @Test
    public void testSetAndGetDescription() {
        String testDescription = "aDescription";
        assertNull(product.getDescription());
        product.setDescription(testDescription);
        assertEquals(testDescription, product.getDescription());
    }

    @Test
    public void testSetAndGetPrice() {
        double testPrice = 100.00;
        assertEquals(0, 0, 0);    
        product.setPrice(testPrice);
        assertEquals(testPrice, product.getPrice(), 0);
    }

}</pre>

<p>A continuación, creamos el servicio <tt class="interfacename">ProductManager</tt>. Éste es el servicio responsable de gestionar los productos. Contiene dos métodos: un método de negocio, <tt class="methodname">increasePrice()</tt>, que incrementa el precio de todos los productos, y un método getter, <tt class="methodname">getProducts()</tt>,
 para recuperar todos los productos. Hemos decidido diseñarlo como una 
interface en lugar de como una clase concreta por algunas razones. 
Primero, es más fácil escribir tests unitarios para los <tt class="literal">Controllers</tt>
 (como veremos en el próximo capitulo). Segundo, el uso de interfaces 
implica que JDK Proxying (una característica del lenguaje Java) puede
ser usada para hacer el servicio transaccional, en lugar de usar CGLIB 
(una librería de generación de código).</p>

<p><tt class="filename">'springapp/src/main/java/com/companyname/springapp/service/ProductManager.java'</tt>:</p>
<pre class="programlisting">package com.companyname.springapp.service;

import java.io.Serializable;
import java.util.List;

import com.companyname.springapp.domain.Product;

public interface ProductManager extends Serializable {

    public void increasePrice(int percentage);
    
    public List&lt;Product&gt; getProducts();

}</pre>

<p>Vamos a crear ahora la clase <tt class="classname">SimpleProductManager</tt>
que implementa la interface <tt class="classname">ProductManager</tt>.</p>

<p><tt class="filename">'springapp/src/main/java/com/companyname/springapp/service/SimpleProductManager.java'</tt>:</p>
<pre class="programlisting">package com.companyname.springapp.service;

import java.util.List;

import com.companyname.springapp.domain.Product;

public class SimpleProductManager implements ProductManager {

    private static final long serialVersionUID = 1L;

    public List&lt;Product&gt; getProducts() {
        throw new UnsupportedOperationException();        
    }

    public void increasePrice(int percentage) {
        throw new UnsupportedOperationException();        
	}
	
    public void setProducts(List&lt;Product&gt; products) {
        throw new UnsupportedOperationException();        
    }
}</pre>

<p>Antes de implementar los métodos en <tt class="classname">SimpleProductManager</tt>,
vamos a definir algunos tests. La definición más estricta de <tt class="literal">Test Driven Development </tt> (TDD) implica escribir siempre los tests primero, y a continuación el código. Una interpretación aproximada se conoce como <tt class="literal">Test Oriented Development</tt>
 (TOD - Desarrollo Orientado a Tests), donde se alternan las tareas de 
escribir el código y los tests como parte del proceso de desarrollo. En 
cualquier caso, lo más importante es tener para el código base el 
conjunto más completo de tests que sea posible. La forma de alcanzar 
este objetivo es más teoría que práctica. Muchos
programadores TDD, sin embargo, están de acuerdo en que la calidad de 
los tests es siempre mayor cuando son escritos al mismo tiempo que el 
código, por lo que ésta es la aproximación que vamos a tomar.</p>
<p>Para escribir test efectivos, tienes que considerar todas las pre- y 
post-condiciones del método que va a ser testeado, así como lo que 
ocurre dentro del método. Comencemos testeando una llamada a <tt class="methodname">getProducts()</tt> que devuelve <tt class="literal">null</tt>.</p>

<p><tt class="filename">'springapp/src/test/java/com/companyname/springapp/service/SimpleProductManagerTests.java'</tt>:</p>
<pre class="programlisting">package com.companyname.springapp.service;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

public class SimpleProductManagerTests {

    private SimpleProductManager productManager;
    
    @Before
    public void setUp() throws Exception {
        productManager = new SimpleProductManager();
    }

    @Test
    public void testGetProductsWithNoProducts() {
        productManager = new SimpleProductManager();
        assertNull(productManager.getProducts());
    }
}</pre>

<p>Si ejecutamos ahora los tests de <tt class="classname">SimpleProductManagerTests</tt> fallarán; ya que, por ejemplo, <tt class="methodname">getProducts()</tt>
todavía no ha sido implementado. Normalmente, es una buena idea marcar
los métodos aún no implementados haciendo que lancen una excepción de
tipo <tt class="classname">UnsupportedOperationException</tt>.</p>
<p>A continuación, vamos a implementar un test para recuperar una
lista de objectos de respaldo en los que han sido almacenados datos de
prueba. Sabemos que tenemos que almacenar la lista de productos en la
mayoria de nuestros tests de <tt class="classname">SimpleProductManagerTests</tt>,
por lo que definimos la lista de objetos de respaldo en el metodo <tt class="methodname">setUp()</tt> de JUnit. Este método, anotado como <tt class="literal">@Before</tt>, será invocado previamente a cada llamada a un método de test.</p>

<p><tt class="filename">'springapp/src/test/java/com/companyname/springapp/service/SimpleProductManagerTests.java'</tt>:</p>
<pre class="programlisting">package com.companyname.springapp.service;

<span class="bold"><b>import java.util.ArrayList;</b></span>
import java.util.List;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

<span class="bold"><b>import com.companyname.springapp.domain.Product;</b></span>

public class SimpleProductManagerTests {

    private SimpleProductManager productManager;
    
    <span class="bold"><b>private List&lt;Product&gt; products;
    
    private static int PRODUCT_COUNT = 2;
    
    private static Double CHAIR_PRICE = new Double(20.50);
    private static String CHAIR_DESCRIPTION = "Chair";
    
    private static String TABLE_DESCRIPTION = "Table";
    private static Double TABLE_PRICE = new Double(150.10);</b></span> 
    
    @Before
    public void setUp() throws Exception {
        productManager = new SimpleProductManager();
        products = new ArrayList&lt;Product&gt;();
        
        // stub up a list of products
        Product product = new Product();
        product.setDescription("Chair");
        product.setPrice(CHAIR_PRICE);
        products.add(product);
        
        product = new Product();
        product.setDescription("Table");
        product.setPrice(TABLE_PRICE);
        products.add(product);
        
        productManager.setProducts(products);

    }

    @Test
    public void testGetProductsWithNoProducts() {
        productManager = new SimpleProductManager();
        assertNull(productManager.getProducts());
    }

    <span class="bold"><b>@Test
    public void testGetProducts() {
        List&lt;Product&gt; products = productManager.getProducts();
        assertNotNull(products);        
        assertEquals(PRODUCT_COUNT, productManager.getProducts().size());
    
        Product product = products.get(0);
        assertEquals(CHAIR_DESCRIPTION, product.getDescription());
        assertEquals(CHAIR_PRICE, product.getPrice());
        
        product = products.get(1);
        assertEquals(TABLE_DESCRIPTION, product.getDescription());
        assertEquals(TABLE_PRICE, product.getPrice());      
    }</b></span>

}</pre>


<p>Si volvemos a lanzar los test de <tt class="classname">SimpleProductManagerTests</tt> seguirán fallando.Para solucionarlo, volvemos a <tt class="classname">SimpleProductManager</tt> e implementamos los métodos getter y setter de la propiedad <tt class="literal">products</tt>.</p>

<p><tt class="filename">'springapp/src/main/java/com/companyname/springapp/service/SimpleProductManager.java'</tt>:</p>
<pre class="programlisting">package com.companyname.springapp.service;

import java.util.List;

import com.companyname.springapp.domain.Product;

public class SimpleProductManager implements ProductManager {

    private static final long serialVersionUID = 1L;

    <span class="bold"><b>private List&lt;Product&gt; products;</b></span>

    public List&lt;Product&gt; getProducts() {
        <span class="bold"><b>return products;</b></span> 
    }

    public void increasePrice(int percentage) {
        throw new UnsupportedOperationException(); 
    }
	
    public void setProducts(List&lt;Product&gt; products) {
        <span class="bold"><b>this.products = products;</b></span>
    }
}</pre>

<p>Relanza los test de nuevo y ahora todos ellos deben pasar.</p>
<p>Ahora procedemos a implementar los siguientes test para el método
<tt class="methodname">increasePrice()</tt>:</p>
<div class="itemizedlist">
<ul type="disc">
	<li>

	<p>La lista de productos es null y el método se ejecuta
	correctamente.</p>
	</li>
	<li>
	<p>La lista de productos esta vacía y el método se ejecuta
	correctamente.</p>
	</li>
	<li>
	<p>Fija un incremento de precio del 10% y comprueba que dicho
	incremento se ve reflejado en los precios de todos los productos de la
	lista.</p>
	</li>
</ul>
</div>
<p><tt class="filename">'springapp/src/test/java/com/companyname/springapp/service/SimpleProductManagerTests.java'</tt>:</p>
<pre class="programlisting">package com.companyname.springapp.service;

import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

import com.companyname.springapp.domain.Product;

public class SimpleProductManagerTests {

    private SimpleProductManager productManager;
    
    private List&lt;Product&gt; products;
    
    private static int PRODUCT_COUNT = 2;
    
    private static Double CHAIR_PRICE = new Double(20.50);
    private static String CHAIR_DESCRIPTION = "Chair";
    
    private static String TABLE_DESCRIPTION = "Table";
    private static Double TABLE_PRICE = new Double(150.10);

    <span class="bold"><b>private static int POSITIVE_PRICE_INCREASE = 10;</b></span> 
    
    @Before
    public void setUp() throws Exception {
        productManager = new SimpleProductManager();
        products = new ArrayList&lt;Product&gt;();
        
        // stub up a list of products
        Product product = new Product();
        product.setDescription("Chair");
        product.setPrice(CHAIR_PRICE);
        products.add(product);
        
        product = new Product();
        product.setDescription("Table");
        product.setPrice(TABLE_PRICE);
        products.add(product);
        
        productManager.setProducts(products);

    }

    @Test
    public void testGetProductsWithNoProducts() {
        productManager = new SimpleProductManager();
        assertNull(productManager.getProducts());
    }

    @Test
    public void testGetProducts() {
        List&lt;Product&gt; products = productManager.getProducts();
        assertNotNull(products);        
        assertEquals(PRODUCT_COUNT, productManager.getProducts().size());
    
        Product product = products.get(0);
        assertEquals(CHAIR_DESCRIPTION, product.getDescription());
        assertEquals(CHAIR_PRICE, product.getPrice());
        
        product = products.get(1);
        assertEquals(TABLE_DESCRIPTION, product.getDescription());
        assertEquals(TABLE_PRICE, product.getPrice());      
    }

    <span class="bold"><b>@Test
    public void testIncreasePriceWithNullListOfProducts() {
        try {
            productManager = new SimpleProductManager();
            productManager.increasePrice(POSITIVE_PRICE_INCREASE);
        }
        catch(NullPointerException ex) {
            fail("Products list is null.");
        }
    }

    @Test
    public void testIncreasePriceWithEmptyListOfProducts() {
        try {
            productManager = new SimpleProductManager();
            productManager.setProducts(new ArrayList&lt;Product&gt;());
            productManager.increasePrice(POSITIVE_PRICE_INCREASE);
        }
        catch(Exception ex) {
            fail("Products list is empty.");
        }           
    }
    
    @Test
    public void testIncreasePriceWithPositivePercentage() {
        productManager.increasePrice(POSITIVE_PRICE_INCREASE);
        double expectedChairPriceWithIncrease = 22.55;
        double expectedTablePriceWithIncrease = 165.11;
        
        List&lt;Product&gt; products = productManager.getProducts();      
        Product product = products.get(0);
        assertEquals(expectedChairPriceWithIncrease, product.getPrice(), 0);
        
        product = products.get(1);      
        assertEquals(expectedTablePriceWithIncrease, product.getPrice(), 0);       
    }</b></span>
}</pre>

<p>Por último, volvemos a <tt class="classname">SimpleProductManager</tt> para
implementar el método <tt class="methodname">increasePrice()</tt>.</p>

<p><tt class="filename">'springapp/src/main/java/com/companyname/springapp/service/SimpleProductManager.java'</tt>:</p>
<pre class="programlisting">package com.companyname.springapp.service;

import java.util.List;

import com.companyname.springapp.domain.Product;

public class SimpleProductManager implements ProductManager {

    private static final long serialVersionUID = 1L;

    private List&lt;Product&gt; products;

    public List&lt;Product&gt; getProducts() {
        return products; 
    }

    public void increasePrice(int percentage) {
        <span class="bold"><b>if (products != null) {
            for (Product product : products) {
                double newPrice = product.getPrice().doubleValue() * 
                                    (100 + percentage)/100;
                product.setPrice(newPrice);
            }
        }</b></span>  
    }
	
    public void setProducts(List&lt;Product&gt; products) {
        this.products = products;
    }
}</pre>

<p>Si volvemos a lanzar los tests de <tt class="classname">SimpleProductManagerTests</tt> ahora deberán pasar todos. ¡HURRA!. JUnit tiene un dicho: “<span class="quote">keep the bar green to keep the code clean (mantén
la barra verde para mantener el código limpio)</span>”.</p>
<p>Ahora estamos listos para movernos a la capa web y para poner una
lista de productos en nuestro modelo <tt class="classname">Controller</tt>.</p>

</div>
<div class="section" lang="en">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both;"><a name="step3.3"></a>3.3.&nbsp;Resumen</h2>
</div>
</div>
<div></div>
</div>

<p>Echemos un rápido vistazo a lo que hemos hecho en la Parte 3.</p>
<div class="orderedlist">
<ol type="1">
	<li>
	<p>Hemos implementado el objeto de dominio <tt class="classname">Product</tt>, la interface de servicio <tt class="interfacename">ProductManager</tt> y la clase concreta <tt class="classname">SimpleProductManager</tt>, todos como POJOs.</p>
	</li>
	<li>
	<p>Hemos escrito tests unitarios para todas las clases que hemos implementado.</p>
	</li>
	<li>

	<p>No hemos escrito ni una sola linea de código de Spring. Éste es
	un ejemplo de lo no-intrusivo que es realmente Spring Framework. Uno de
	sus propósitos principales es permitir a los programadores centrarse en
	la parte más importante de todas: modelar e implementar
	requerimientos de negocio. Otro de sus propósitos es hacer seguir las
	mejores prácticas de programación de una manera sencilla, como por 
ejemplo implementar servicios usando interfaces y usar tests unitarios 
más allá de las
	obligaciones prágmaticas de un proyecto dado. A lo largo de este
	tutorial, verás como los beneficios de diseñar interfaces cobran vida.</p>
	</li>
</ol>
</div>
<p>A continuación puedes ver una captura de pantalla que muestra el aspecto que debería
tener la estructura de directorios del proyecto después de seguir todas las instrucciones anteriores.</p>



<div class="screenshot">
<div class="mediaobject" align="center"><img src="Cap%C3%ADtulo%C2%A03.%C2%A0Desarrollando%20la%20Logica%20de%20Negocio%20Archivos/dir-structure-endp3.png" align="middle">
<div class="caption">
<p>La estructura de directorios del proyecto al final de la parte 3
</p>
</div>
</div>
</div>
</div>
</div>
<div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter">
<hr>
<table summary="Navigation footer" width="100%">
	<tbody>
		<tr>
			<td align="left" width="40%"><a accesskey="p" href="http://www.uv.es/grimo/teaching/SpringMVCv4PasoAPaso/part2.html">Anterior</a>&nbsp;</td>
			<td align="center" width="20%"><a accesskey="h" href="http://www.uv.es/grimo/teaching/SpringMVCv4PasoAPaso/index.html">Inicio</a></td>
			<td align="right" width="40%">&nbsp;<a accesskey="n" href="http://www.uv.es/grimo/teaching/SpringMVCv4PasoAPaso/part4.html">Siguiente</a></td>
		</tr>
		<tr>
			<td align="left" valign="top" width="40%">Capítulo&nbsp;2.&nbsp;Desarrollando
			y Configurando la Vista y el Controlador&nbsp;</td>
			<td align="center" width="20%"><span style="color: white; font-size: 90%;"><a href="http://www.uv.es/grimo">Autor: Francisco Grimaldo Moreno</a></span></td>
			<td align="right" valign="top" width="40%">&nbsp;Capítulo&nbsp;4.&nbsp;Desarrollando
			la Interface Web</td>
		</tr>
	</tbody>
</table>
</div>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script><script src="Cap%C3%ADtulo%C2%A03.%C2%A0Desarrollando%20la%20Logica%20de%20Negocio%20Archivos/ga.js" type="text/javascript"></script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4959413-1");
pageTracker._trackPageview();
} catch(err) {}</script>


</body></html>